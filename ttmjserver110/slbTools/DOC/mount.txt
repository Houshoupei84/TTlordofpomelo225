步骤 4：格式化和挂载数据盘

如果您在创建实例时选择了数据盘，在登录实例后，系统需要先格式化数据盘，然后挂载数据盘。

另外，您还可以根据业务需要，对数据盘进行多分区配置。建议使用系统自带的工具进行分区操作。

注意：云服务器 ECS 仅支持对 数据盘 进行二次分区，而不支持对 系统盘 进行二次分区（不管是 Windows 还是 Linux 系统）。如果您强行使用第三方工具对系统盘进行二次分区操作，可能引发未知风险，如系统崩溃、数据丢失等。

本操作适用于 非 I/O 优化+SSD云盘 Linux （Redhat、CentOS、Debian、Ubuntu）实例。对于 I/O 优化实例+SSD云盘数据盘分区挂载，建议使用 脚本工具：auto_fdisk_ssd.sh

使用管理终端，或远程连接工具，输入用户名 root 和密码登录到实例。
运行 fdisk -l 命令查看数据盘。注意：在没有分区和格式化数据盘之前，使用 df -h 命令是无法看到数据盘的。在下面的示例中，有一个 5 GB 的数据盘需要挂载。 
如果执行了 fdisk -l 命令后，没有发现 /dev/xvdb，则表示您的实例没有数据盘，因此无需挂载。可以忽略这一章。1
运行 fdisk /dev/xvdb，对数据盘进行分区。根据提示，依次输入 n，p，1，两次回车，wq，分区就开始了。2
运行 fdisk -l 命令，查看新的分区。新分区 xvdb1 已经创建好。如下面示例中的/dev/xvdb1。3
运行 mkfs.ext3 /dev/xvdb1，对新分区进行格式化。格式化所需时间取决于数据盘大小。您也可自主决定选用其他文件格式，如 ext14 等。4
运行 echo ‘/dev/xvdb1 /mnt ext3 defaults 0 0’>> /etc/fstab 写入新分区信息。完成后，可以使用 cat /etc/fstab 命令查看。5 
注意： Ubuntu 12.04 不支持 barrier，所以对该系统正确的命令是：echo ‘/dev/xvdb1 /mnt ext3 barrier=0 0 0’>>/etc/fstab 
如果需要把数据盘单独挂载到某个文件夹，比如单独用来存放网页，可以修改以上命令中的 /mnt 部分。
运行 mount /dev/xvdb1 /mnt 挂载新分区，然后执行 df -h 查看分区。如果出现数据盘信息，说明挂载成功，可以使用新分区了。
 mount /dev/xvdb1 /mnt
 df -h
 Filesystem      Size  Used Avail Use% Mounted on
 /dev/xvda1       40G  1.5G   36G   4% /
 tmpfs           498M     0  498M   0% /dev/shm
 /dev/xvdb1      5.0G  139M  4.6G   3% /mnt
 
 
 
 // 具体执行步骤如下
 
 fdisk -l

 fdisk /dev/vdb	n，p，1，两次回车，wq，

 mkfs.ext3 /dev/vdb1

 echo ‘/dev/vdb1 /mnt ext3 defaults 0 0’>> /etc/fstab
 
 mkdir /mnt/vdb1
 mount /dev/vdb1 /mnt/vdb1
 
 
 
 cd /mnt/vdb1
 mkdir 2016-07-13

 =======================================================
 
 // 2T以上大硬盘的操作
 在Linux中，由于ext3文件系统不支持大于2TB的分区，所以要使用GPT分区格式。可利用parted命令来完成分区。
 
 命令fdisk -l，看一下。例如/dev/vdb是新增的硬盘空间，大于2TB。
 
 parted /dev/vdb		进入parted分区工具。
 mklabel gpt			把/dev/vdb 改成gpt大分区格式。
 print   命令print，查看sdb分区状态。可以看到已经打上了gpt的标签。
 
 // 提示性能问题
 //(parted) mkpart primary 0 100%
//Warning: The resulting partition is not properly aligned for best performance.
//Ignore/Cancel?

 mkpart primary 2048s 100%
//如果一切顺利，分区将会被成功创建并没有任何警告信息。然后你就可以检查分区是否对齐了（如有必要，请将下面命令中的1替换为合适的分区号）。
//(parted) align-check optimal 1                                            
//1 aligned
 
 quit
 
 
 mkfs.ext4 -F /dev/vdb	
 
  mount /dev/vdb1 /mnt/vdb1

 
 
 
 How to align partitions for best performance using parted
There are two common problems when creating partitions in Linux on big storage arrays. The first is easy, and the warning message from fdisk is a bit of a giveaway:

WARNING: The size of this disk is 8.0 TB (7970004230144 bytes).
DOS partition table format can not be used on drives for volumes
larger than (2199023255040 bytes) for 512-byte sectors. Use parted(1) and GUID 
partition table format (GPT).
The answer: use parted. Don’t have it? Install it!

The second problem is this warning from parted:

(parted) mklabel gpt
(parted) mkpart primary 0 100%
Warning: The resulting partition is not properly aligned for best performance.
Ignore/Cancel?
…and no matter what combination of numbers you use, the message just keeps coming back. It’s tempting to ignore it, but don’t.

There are a few posts on the subject, but this one from HP really gets to the guts of the problem.

Here’s a quick step-by-step guide to aligning partitions properly. It’s just an abstraction of the HP post, but hopefully easier to follow. This will work for most arrays (in fact it works for all the arrays that I’ve seen); there are more options in HP’s post, but I’ve included the most common configuration here.

1. Get the alignment parameters for your array (remember to replace sdb with the name of your device as seen by the kernel).

    # cat /sys/block/sdb/queue/optimal_io_size
    1048576
    # cat /sys/block/sdb/queue/minimum_io_size
    262144
    # cat /sys/block/sdb/alignment_offset
    0
    # cat /sys/block/sdb/queue/physical_block_size
    512
2. Add optimal_io_size to alignment_offset and divide the result by physical_block_size. In my case this was (1048576 + 0) / 512 = 2048.
3. This number is the sector at which the partition should start. Your new parted command should look like

    mkpart primary 2048s 100%
The trailing ‘s’ is important: it tells parted that you’re talking about sectors, not bytes or megabytes.

4. If all went well, the partition will have been created with no warnings. You can check the alignment thusly (replacing ’1′ with the partition number if necessary):

    (parted) align-check optimal 1                                            
    1 aligned
As I alluded to before, there are cases where this won’t work: if optimal_io_size is zero, for example, there are other rules to follow. Of course it would be nice if parted could do this—the values are all available as ioctls, after all—but then what would I write about? :) 

末尾的最后一条评论更加实用：
Apparently, using % causes parted to automatically align the sectors for best performance:

(parted) mkpart primary ext4 0% 100%
 
 
 